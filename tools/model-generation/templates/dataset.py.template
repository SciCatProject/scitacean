# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2023 SciCat Project (https://github.com/SciCatProject/scitacean)
# flake8: noqa

"""Base dataclass for Dataset."""

from __future__ import annotations

import dataclasses
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Literal, Optional, Union

import dateutil.parser

from .datablock import OrigDatablockProxy
from .filesystem import RemotePath
from .model import (
    DatasetLifecycle,
    DatasetType,
    DerivedDataset,
    OrigDatablock,
    RawDataset,
    Technique,
)
from .pid import PID


def _apply_default(
    value: Any, default: Any, default_factory: Optional[Callable[[], Any]]
) -> Any:
    if value is not None:
        return value
    if default_factory is not None:
        return default_factory()
    return default


def _parse_datetime(x: Optional[Union[datetime, str]]) -> datetime:
    if isinstance(x, datetime):
        return x
    if isinstance(x, str):
        if x != "now":
            return dateutil.parser.parse(x)
    return datetime.now(tz=timezone.utc)


class DatasetFields:
    @dataclasses.dataclass(frozen=True)
    class Field:
        name: str
        description: str
        read_only: bool
        required_by_derived: bool
        required_by_raw: bool
        type: type
        used_by_derived: bool
        used_by_raw: bool

        def required(self, dataset_type: DatasetType) -> bool:
            return (
                self.required_by_raw
                if dataset_type == DatasetType.RAW
                else self.required_by_derived
            )

        def used_by(self, dataset_type: DatasetType) -> bool:
            return self.used_by_raw if dataset_type == DatasetType.RAW else self.used_by_derived

    _FIELD_SPEC = $field_spec

    def __init__(
        self,
        *,
        type: Union[DatasetType, Literal["derived", "raw"]],
        creation_time: Optional[Union[datetime, str]] = None,
        pid: Optional[Union[str, PID]] = None,
        $field_init_args,
        checksum_algorithm: Optional[str] = "blake2b",
        _read_only: Optional[Dict[str, Any]] = None,
        _orig_datablocks: Optional[List[OrigDatablockProxy]] = None,
    ):
        """Construct a dataset with given values.

        All arguments correspond to dataset fields, except `checksum_algorithm` which
        is used as the default algorithm when files are added.

        Arguments starting with an underscore are used internally to initialize
        datasets from SciCat models, and you should generally avoid setting them
        yourself!
        """
        _read_only = _read_only or {}
        self._fields = {
            "creation_time": _parse_datetime(creation_time),
            "history": _apply_default(_read_only.get("history"), None, None),
            "pid": PID.parse(pid) if isinstance(pid, str) else pid,
            "type": DatasetType(type),
$field_dict_construction
        }
        self._orig_datablocks = (
            [] if _orig_datablocks is None else list(_orig_datablocks)
        )
        self._default_checksum_algorithm = self._validate_checksum_algorithm(
            checksum_algorithm
        )

    @staticmethod
    def _validate_checksum_algorithm(algorithm: Optional[str]) -> Optional[str]:
        if algorithm is None:
            return algorithm
        import hashlib

        if algorithm not in hashlib.algorithms_available:
            raise ValueError(f"Checksum algorithm not recognized: {algorithm}")
        return algorithm

    @property
    def type(self) -> DatasetType:
        """Dataset type, Derived or Raw."""
        return self._fields["type"]  # type: ignore[no-any-return]

    @type.setter
    def type(self, val: DatasetType) -> None:
        """Dataset type, Derived or Raw."""
        self._fields["type"] = val

    @property
    def pid(self) -> Optional[PID]:
        """Persistent identifier for datasets."""
        return self._fields["pid"]  # type: ignore[no-any-return]

    @pid.setter
    def pid(self, pid: Optional[Union[PID, str]]) -> None:
        """Persistent identifier for datasets."""
        self._fields["pid"] = None if pid is None else PID.parse(pid)

    @property
    def creation_time(self) -> datetime:
        """Time when the dataset became fully available on disk,
        i.e. all containing files have been written."""
        return self._fields["creation_time"]  # type: ignore[no-any-return]

    @creation_time.setter
    def creation_time(self, value: Union[datetime, str]) -> None:
        """Time when the dataset became fully available on disk,
        i.e. all containing files have been written."""
        if value is None:
            raise TypeError("Cannot set creation_time to None")
        self._fields["creation_time"] = _parse_datetime(value)

$properties

$make_derived_model

$make_raw_model


def fields_from_model(model: Union[DerivedDataset, RawDataset]) -> dict:
    return (
        _fields_from_derived_model(model)
        if isinstance(model, DerivedDataset)
        else _fields_from_raw_model(model)
    )


$fields_from_derived_model

$fields_from_raw_model
