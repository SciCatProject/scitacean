# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022 Scitacean contributors (https://github.com/SciCatProject/scitacean)
# @author Jan-Lukas Wynen
# flake8: noqa

"""Base dataclass for Dataset."""

import dataclasses
from datetime import datetime, timezone
from typing import Any, Callable, Dict, Generator, Literal, List, Optional, Union

import dateutil.parser

from .pid import PID
from .model import DatasetType, DerivedDataset, RawDataset


def _apply_default(value: Any, default: Any, default_factory: Optional[Callable]) -> Any:
    if value is not None:
        return value
    if default_factory is not None:
        return default_factory()
    return default


def _parse_datetime(x: Optional[Union[datetime, str]])->datetime:
    if isinstance(x, datetime):
        return x
    if isinstance(x, str):
        if x != "now":
            return dateutil.parser.parse(x)
    return datetime.now(tz=timezone.utc)


class DatasetFields:
    @dataclasses.dataclass(frozen=True)
    class Field:
        name: str
        description: str
        read_only: bool
        required_by_derived: bool
        required_by_raw: bool
        type: type
        used_by_derived: bool
        used_by_raw: bool

    _FIELD_SPEC = $field_spec


    def __init__(self,
                 *,
                 type: Union[DatasetType, Literal["derived", "raw"]],
                 creation_time: Optional[Union[datetime, str]]=None,
                 $field_init_args,
                 _read_only: Optional[Dict[str, Any]]=None,
                 _pid: Optional[Union[str, PID]]=None):
        _read_only = _read_only or {}
        self._fields = {
            "creation_time": _parse_datetime(creation_time),
            "history": _apply_default(_read_only.get("history"), None, list),
            "pid": PID.parse(_pid) if isinstance(_pid, str) else _pid,
            "type": DatasetType(type),
$field_dict_construction
        }

    @property
    def pid(self) -> Optional[PID]:
        """Persistent identifier for datasets."""
        return self._fields["pid"]

    @property
    def creation_time(self) -> datetime:
        return self._fields["creation_time"]

    @creation_time.setter
    def creation_time(self, value: Union[datetime, str]):
        if value is None:
            raise TypeError("Cannot set creation_time to None")
        self._fields["creation_time"] = _parse_datetime(value)

$properties

    @classmethod
    def fields(cls, type: Optional[Union[DatasetType, Literal["derived", "raw"]]]=None,
               read_only: Optional[bool]=None) -> Generator[Field, None, None]:
        """Iterator over dataset fields."""
        it = DatasetFields._FIELD_SPEC
        if type is not None:
            attr = "used_by_derived" if type == DatasetType.DERIVED else "used_by_raw"
            it = filter(lambda field: getattr(field, attr), it)
        if read_only is not None:
            it = filter(lambda field: field.read_only == read_only, it)
        yield from it

    def __str__(self) -> str:
        args = ", ".join(f"{name}={value}" for name, value in ((field.name, getattr(self, field.name)) for field in self.fields()) if value is not None)
        return f"Dataset({args})"

    def make_dataset_model(self) -> Union[DerivedDataset, RawDataset]:
        if self.type == DatasetType.DERIVED:
            return self._make_derived_model()
        return self._make_raw_model()

$make_derived_model

$make_raw_model
