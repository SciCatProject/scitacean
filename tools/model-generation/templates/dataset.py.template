# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2023 SciCat Project (https://github.com/SciCatProject/scitacean)
# flake8: noqa

"""Base dataclass for Dataset."""

from __future__ import annotations

import dataclasses
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Literal, Optional, Union

import dateutil.parser

from .datablock import OrigDatablockProxy
from .filesystem import RemotePath
from .model import (
    DatasetLifecycle,
    DatasetType,
    DerivedDataset,
    OrigDatablock,
    RawDataset,
    Technique,
)
from .pid import PID


def _apply_default(
    value: Any, default: Any, default_factory: Optional[Callable]
) -> Any:
    if value is not None:
        return value
    if default_factory is not None:
        return default_factory()
    return default


def _parse_datetime(x: Optional[Union[datetime, str]]) -> datetime:
    if isinstance(x, datetime):
        return x
    if isinstance(x, str):
        if x != "now":
            return dateutil.parser.parse(x)
    return datetime.now(tz=timezone.utc)


class DatasetFields:
    @dataclasses.dataclass(frozen=True)
    class Field:
        name: str
        description: str
        read_only: bool
        required_by_derived: bool
        required_by_raw: bool
        type: type
        used_by_derived: bool
        used_by_raw: bool

        def required(self, dataset_type: DatasetType) -> bool:
            return (
                self.required_by_raw
                if dataset_type == DatasetType.RAW
                else self.required_by_derived
            )

    _FIELD_SPEC = $field_spec

    def __init__(
        self,
        *,
        type: Union[DatasetType, Literal["derived", "raw"]],
        creation_time: Optional[Union[datetime, str]] = None,
        $field_init_args,
        checksum_algorithm: Optional[str] = "md5",
        _pid: Optional[Union[str, PID]] = None,
        _read_only: Optional[Dict[str, Any]] = None,
        _orig_datablocks: Optional[List[OrigDatablockProxy]] = None,
    ):
        """Construct a dataset with given values.

        All arguments correspond to dataset fields, except `checksum_algorithm` which
        is used as the default algorithm when files are added.

        Arguments starting with an underscore are used internally to initialize
        datasets from SciCat models, and you should generally avoid setting them
        yourself!
        """
        _read_only = _read_only or {}
        self._fields = {
            "creation_time": _parse_datetime(creation_time),
            "history": _apply_default(_read_only.get("history"), None, list),
            "pid": PID.parse(_pid) if isinstance(_pid, str) else _pid,
            "type": DatasetType(type),
$field_dict_construction
        }
        self._orig_datablocks = (
            [] if _orig_datablocks is None else list(_orig_datablocks)
        )
        self._default_checksum_algorithm = self._validate_checksum_algorithm(
            checksum_algorithm
        )

    @staticmethod
    def _validate_checksum_algorithm(algorithm: Optional[str]):
        if algorithm is None:
            return algorithm
        import hashlib

        if algorithm not in hashlib.algorithms_available:
            raise ValueError(f"Checksum algorithm not recognized: {algorithm}")
        return algorithm

    @property
    def pid(self) -> Optional[PID]:
        """Persistent identifier for datasets."""
        return self._fields["pid"]

    @property
    def creation_time(self) -> datetime:
        """Time when dataset became fully available on disk,
        i.e. all containing files have been written."""
        return self._fields["creation_time"]

    @creation_time.setter
    def creation_time(self, value: Union[datetime, str]):
        """Time when dataset became fully available on disk,
        i.e. all containing files have been written."""
        if value is None:
            raise TypeError("Cannot set creation_time to None")
        self._fields["creation_time"] = _parse_datetime(value)

$properties

    def __str__(self) -> str:
        args = ", ".join(
            f"{name}={value}"
            for name, value in (
                (field.name, getattr(self, field.name)) for field in self.fields()
            )
            if value is not None
        )
        return f"Dataset({args})"

$make_derived_model

$make_raw_model


def fields_from_model(model: Union[DerivedDataset, RawDataset]) -> dict:
    return (
        _fields_from_derived_model(model)
        if isinstance(model, DerivedDataset)
        else _fields_from_raw_model(model)
    )


$fields_from_derived_model

$fields_from_raw_model